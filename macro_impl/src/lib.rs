use std::collections::HashMap;

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(PiFn)]
pub fn derive_pi(_item: TokenStream) -> TokenStream {
    "fn pi() -> f32 { 22./7. }".parse().unwrap()
}

// YUCK! without `syn`, we're kinda lost in tokens. I don't advise trying to understand this,
// instead skip to the next macro (SynChatty)
#[proc_macro_derive(Chatty)]
pub fn chatty(input: TokenStream) -> TokenStream {
    for item in input {
        match item {
            proc_macro::TokenTree::Group(group) => {
                for item in group.stream() {
                    match item {
                        proc_macro::TokenTree::Ident(ident) => {
                            println!("found ident: {:?}", ident);
                        }
                        _ => {}
                    }
                }
            }
            //proc_macro::TokenTree::Ident(ident) => {},
            //proc_macro::TokenTree::Punct(_) => {},
            //proc_macro::TokenTree::Literal(_) => {},
            _ => {}
        }
    }
    TokenStream::new()
}

#[proc_macro_derive(SynChatty)]
pub fn syn_chatty(input: TokenStream) -> TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(input as DeriveInput);

    let name = input.ident;
    let mut value_fields = HashMap::new();
    // output when proc macro runs - at compile time
    println!("Id: {}", name);

    match input.data {
        // only operate on structs
        syn::Data::Struct(s) => {
            // iterate over the struct's fields that have identifiers ( = are not anonymous)
            for field in s.fields {
                if let Some(ident) = field.ident {
                    match field.ty {
                        // if the type of a field is a "Path" (something like std::String),
                        syn::Type::Path(p) => {
                            // and that Path also has an identifier
                            // (exotic if not, but we need to make sure)
                            if let Some(path_ident) = p.path.get_ident() {
                                // output when proc macro runs - at compile time
                                println!("found named field: {:?}: {:?};", ident, path_ident);

                                // memorize the field name and type name
                                value_fields.insert(ident, path_ident.clone());
                            }
                        }
                        _ => {}
                    }
                }
            }
        }

        // crash on enums
        syn::Data::Enum(_e) => todo!(),
        // ... and unions
        syn::Data::Union(_u) => todo!(),
    }

    let k = value_fields.keys();
    let v = value_fields.values();

    let field_names = value_fields.keys().map(|i| i.to_string());

    // generate getter code for every field. #(...)* is repetition,
    // we are simultaneously iterating over k and v so we have #k + #v available
    // (#k expands to current-value-of-k, #v current-of-v)
    let getters = quote! {
        #( fn #k(&self) -> &#v { &self.#k})*
    };

    let expanded = quote! {
        // we can use Rust variables in quote!() - here: strings
        // (name is the name of the struct our derive got called)
        impl #name {

            // but we can also add chunks of Rust previously generated by quote!(...) !!!ยก!11!
            #getters

            fn introspect(&self) {
                println!("*** I have some fields! ***");
                for field in [ #(#field_names),* ] {
                    println!("{}", field);
                }
            }
        }
    };

    // return the newly created code
    TokenStream::from(expanded)
}
